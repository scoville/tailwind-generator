## Pyaco (Polyglot tYpe sAfe Css tOolbox)

_For the old version of this application, please go [here](https://github.com/scoville/tailwind-generator/tree/master)._

This repository contains several binaries and libraries to help you deal with css stylesheet in a type safe manner.

### Pyaco generate: a type safe CSS to "\*" code generator, tailored for Tailwind

Generates code from _any_ valid css file (this CLI has been tested against complex CSS files generated by Tailwind). Currently supports TypeScript, ReScript, Elm, PureScript, and Rust (via a `css!` macro that doesn't require code generation, see below).

### Installation notice

This new version can be installed using npm/yarn using this command:

```bash
npm install https://github.com/scoville/tailwind-generator\#v2
```

or

```bash
yarn add https://github.com/scoville/tailwind-generator\#v2
```

### Commands:

To get help:

```bash
pyaco generate --help
```

```
pyaco-generate
Generate code from a css input

USAGE:
    pyaco generate [FLAGS] [OPTIONS] --input <input> --output-filename <output-filename> --lang <lang>

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information
    -w, --watch      Watch for changes in the provided css file and regenarate the code (doesn't
                     work with URL)

OPTIONS:
    -i, --input <input>
            CSS file path and/or URL to parse and generate code from

    -l, --lang <lang>
            Language used in generated code (elm|purescript|rescript|typescript|typescript-type-
            1|typescript-type-2)"

    -o, --output-directory <output-directory>    Directory for generated code [default: ./]
    -f, --output-filename <output-filename>
            Filename (without extension) used for the generated code
```

`pyaco generate` uses [env_logger](https://docs.rs/env_logger/0.8.4/env_logger/) under the hood, so you can prefix your command with `RUST_LOG=info` for a more verbose output, the binary is silent by default.

Warning: in PureScript and Elm, the provided filename and directory path will be used as the module name, make sure they follow the name conventions and are capitalized. For example:

```bash
pyaco generate -i ./styles.css -l purescript -o ./Foo/Bar -f Baz
```

Will generate a `./Foo/Bar/Baz.purs` file that defines a module called `Foo.Bar.Baz`.

### Examples

Display the help message:

```bash
pyaco generate -h
```

Generates a TypeScript file called `css.ts` in the `generated` folder from the Tailwind css file:

```bash
pyaco generate \
  -i https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css \
  -l typescript \
  -f css \
  -o generated
```

Same as above but generated from a file:

```bash
pyaco generate \
  -i ./styles.css \
  -l typescript \
  -f css \
  -o generated
```

Same as above and regenerate code on `styles.css` file change:

```bash
pyaco generate \
  -i ./styles.css \
  -l typescript \
  -f css \
  -o generated \
  -w
```

Generates a PureScript file and shows logs:

```bash
RUST_LOG=info pyaco generate \
  -i ./styles.css \
  -l purescript \
  -f Css
```

_Warning: the `-w|--watch` mode is still experimental and some bugs are already known (the file is sometimes regenerated twice), use with care._

### Generators

#### TypeScript

`pyaco generate` offers three flavors for TypeScript code generation, let's see and compare the three solutions.

#### TypeScript (typescript)

A simple generator for TypeScript, it exports an [opaque type](https://en.wikipedia.org/wiki/Opaque_data_type) `CssClass`, a `join` function, and a set of `CssClass` "objects":

```ts
import { join, textBlue100, rounded, border, borderBlue300 } from "./css.ts";

// ...

<div className={join([textBlue100, rounded, border, borderBlue300])}>
  Hello
</div>;
```

Pros:

- Easy to use
- Very flexible
- Compatible with most TypeScript versions
- Safe, you can't pass any string to the `join` function
- Autocompletion

Cons:

- Cost at runtime: `CssClass` are JavaScript objects that help ensuring type opacity
- Cost at runtime: the array has to be joined into a string
- Imports can be verbose (unless you use `import * as ...`)
- Not the "standard" class names, `h-full` becomes `hFull`, etc...

#### TypeScript type 1 (typescript-type-1) (recommended)

This generator doesn't generate any runtime code apart from the `join` function.

```ts
import { join } from "./css.ts";

// ...

<div className={join("text-blue-100", "rounded", "border", "border-blue-300")}>
  Hello
</div>;
```

Pros:

- Easy to use
- Very flexible
- Compatible with most TypeScript versions
- Safe, you can't pass any string to the `tailwind` function
- "Standard" class names
- Light import (you only need the `join` function)
- Autocomplete

Cons:

- Cost at runtime: the classes must be "joined" into a string

#### TypeScript type 2 (typescript-type-2)

This generator doesn't generate any runtime code apart from the `css` function.

```ts
import { css } from "./css.ts";

// ...

<div className={css("text-blue-100 rounded border border-blue-300")}>
  Hello
</div>;
```

Pros:

- Super easy to use
- Safe, you can't pass any string to the `tailwind` function
- "Standard" class names
- Light import (you only need the `css` function)
- No runtime cost at all
- Partial support for autocompletion

Cons:

- Not as flexible as the 2 other generators
- Compatible with TypeScript > 4.1 only
- Type error can be hard to debug
- Doesn't accept multiple spaces (not necessarily a cons for some)

#### PureScript (purescript)

In PureScript, a `CssClass` newtype is exported _without its constructor_ which derives some very useful type classes like Semigroup or Monoid offering a lot of flexibility:

- Simple list of css classes:

```purescript
[ rounded, borderRed100 ]
```

- Add a class conditionally:

```purescript
[ if true then textBlue500 else textRed500 ] -- "text-blue-500"
```

- Add a class only if a condition is met, do nothing otherwise:

```purescript
[ guard true textBlue500 ] -- "text-blue-500"
[ guard false rounded ] -- ""
```

- Handle Maybe, and other Foldable values:

```purescript
[ rounded, fold Nothing ] -- "rounded"
[ rounded, fold $ Right wFull ] -- "rounded w-full"

let mClass = Just borderRed100 in
[ rounded, fold mClass ] -- "rounded border-red-100"
```

Example:

```purescript
import Css (rounded, borderRed100, join)

css :: String
css = join [ rounded, borderRed100 ]
```

#### ReScript (rescript)

_You can also take a look at [this ppx](https://github.com/dylanirlbeck/tailwind-ppx) if you want to skip the code generation step. Both approach (code generation and ppx) have pros and cons._

In ReScript 2 files are generated, one that contains the code and an interface file.

Additionally to the class variables, 2 functions are exposed:

- `join`: takes a list of `cssClass` and returns a string
- `joinOpt`: takes a list of `option<cssClass>` and returns a string

```rescript
open Css

<div className={join([textBlue100, rounded, border, borderBlue300])}>
  {"Hello!"->React.string}
</div>
```

#### ReScript type (rescript-type)

Since ReScript 9.1 we can safely coerce [polymorphic variants to strings](https://rescript-lang.org/blog/release-9-1#polymorphic-variants-for-numbers-and-strings). This generator leverages this new feature.

It's lighter than the other ReScript generator, and it's possible to get class names autocompletion using the [Tailwind IntelliSense](https://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcss) plugin.

Example:

```rescript
<div className={Css.join([#"text-blue-100", #rounded, #border, #"border-blue-300"])}>
  {"Hello!"->React.string}
</div>
```

#### Elm (elm)

Additionally to the generated classes, you'll get 2 useful functions:

- `classes`: takes a list of css classes and returns an `Html.Attribute msg` that can be used with any html element
- `join`: performs a simple `List CssClass -> String` conversion when you need to compute a class name outside of an html element

```elm
import Css exposing (classes, textBlue100, rounded, border, borderBlue300);

view _model =
  div [ classes [ textBlue100, rounded, border, borderBlue300 ] ]
    [ text "Hello!" ]
```

### No generators

Some languages allow for more flexibility using macros or some other mechanism. Rust, Crystal, or the OCaml languages (Ocaml, ReasonML, and ReScript) are some of those languages, and `pyaco` offers support for a few of them.

_ReScript users: this tool doesn't offer any other support than the generator (see above) yet, in the meantime you can take a look at [this ppx](https://github.com/dylanirlbeck/tailwind-ppx)._

#### Rust

_TODO: Add notice about installation after release._

In Rust, a `pyaco.toml` file is required and must be located at the root of your crate. It's pretty simple (as of today) and should look like this:

```toml
[general]
input = "./styles.css" # or input = {path = "./styles.css"}
```

Notice that urls are also supported, which can come in handy when testing or developing your application as in that case no file is needed:

```toml
[general]
input = {url = "https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css"}
```

If your config file is valid and the css can be found, you can now use the `css!` macro:

```rust
use pyaco_macro::css;

// ...

let style = css!(" rounded  border px-2  py-1");

// Notice that extra white spaces have been removed at compile time
assert_eq!(style, "rounded border px-2 py-1");
```

The css class names are validated and cleaned at compile time, duplicates are removed (and a compiler warning is emitted if you're using Rust nightly) and the whole macro call is replaced by the provided string itself.

_[Yew](https://yew.rs/) users: the `css!` macro can be used instead of the `classes!` one._

### Pyaco validate: A type safe CSS / code validator _Experimental_

The `pyaco validate` command will take a css input (path or URL) and a glob of files to validate. If a class is used in a file but not present in the css input an error is displayed.

`pyaco validate` will not force you to change your workflow, nor will it add files to your project. It's not a macro/ppx/generator either.

Put simply, it's a super powerful grep, that will read all the files you want to validate, check for the css class names, and exit. Since it's extremely fast (less than 2 seconds to analyze more than 5000 files that all contained more than 600 lines of code on my pretty old machine, not even half a second on ~500 files projects), it can integrate easily with your favorit CI tool.

_This binary is still experimental as we still need to test it out more on larger codebase in TypeScript first, also some quality of life improvements are much needed and are still being worked on (watch mode, whitelist, configuration file, etc...)._
